<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Cordova-friendly viewport to prevent pinch-zoom / resizing -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Jawsome Matt-venture</title>
  <style>
    html, body { height:100%; margin:0; background:#92d4ff; font-family: system-ui, sans-serif; overflow:hidden; }
    #game { display:block; width:100vw; height:100vh; outline:none; }

    /* --- Touch controls (always visible on mobile/Cordova) --- */
    #touch { position: fixed; inset: 0; pointer-events: none; z-index: 5; }
    #joystick {
      position: absolute; bottom: 24px; left: 24px;
      width: 140px; height: 140px; border-radius: 50%;
      background: rgba(255,255,255,.35); backdrop-filter: blur(3px);
      pointer-events: auto; touch-action: none;
    }
    #stick {
      position: absolute; left: 45px; top: 45px; width: 50px; height: 50px; border-radius: 50%;
      background: rgba(255,255,255,.92); box-shadow: 0 2px 6px rgba(0,0,0,.25);
      transition: transform .05s linear;
    }
    #btnJump {
      position: absolute; bottom: 36px; right: 28px;
      width: 92px; height: 92px; border-radius: 50%; border: 0;
      background: #ffffffcc; box-shadow: 0 2px 6px rgba(0,0,0,.25);
      font-size: 28px; pointer-events: auto; touch-action: manipulation;
    }
    /* Hide touch UI only on mouse/keyboard desktop */
    @media (hover: hover) and (pointer: fine) { #touch { display:none; } }

    /* --- Start screen --- */
    #startScreen {
      position: fixed; inset: 0; z-index: 10;
      display:flex; align-items:center; justify-content:center; background:#92d4ff;
      transition: opacity .8s ease;
    }
    #startScreen img { max-width: 90%; max-height: 80vh; cursor: pointer; }
    #startScreen.hidden { opacity: 0; pointer-events: none; }

    /* --- HUD --- */
    #hud {
      position: fixed; top: 10px; right: 12px; z-index: 6;
      background: rgba(0,0,0,.35); color: #fff; padding: 6px 10px; border-radius: 8px;
      font: 12px/1.2 system-ui, sans-serif;
    }
  </style>
</head>
<body>
  <canvas id="game" tabindex="0"></canvas>

  <!-- HUD -->
  <div id="hud" aria-hidden="true">Level 1 / 10</div>

  <!-- Touch controls -->
  <div id="touch">
    <div id="joystick"><div id="stick"></div></div>
    <button id="btnJump" aria-label="Jump">â¤’</button>
  </div>

  <!-- Start screen (tap image to start) -->
  <div id="startScreen"><img id="startImage" src="assets/matt-loading.png" alt="Start" /></div>

  <script>
  // ===== Canvas =====
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d', { alpha:false });
  function resize(){ cvs.width = innerWidth; cvs.height = innerHeight; }
  addEventListener('resize', resize, { passive:true }); resize();

  // Focus canvas so desktop keys always work
  function focusCanvas(){ try{ cvs.focus(); }catch{} }
  focusCanvas();

  // ===== Assets =====
  const SPRITES = { idle:null, run:null, duck:null, climb:null };
  const loadImage = (url)=> new Promise((res,rej)=>{ const i=new Image(); i.src=url; i.onload=()=>res(i); i.onerror=rej; });
  async function ensureSprites(){
    const safe = async (p,f)=>{ try{ return await p; }catch{ return f; } };
    const fb = (label)=>{ const c=document.createElement('canvas'); c.width=64; c.height=96; const g=c.getContext('2d'); g.fillStyle='#5a86ff'; g.fillRect(0,0,64,96); g.fillStyle='#fff'; g.font='12px system-ui'; g.fillText(label,6,16); return c; };
    SPRITES.idle = await safe(loadImage('assets/shark-idle.png'), fb('idle'));
    SPRITES.run  = await safe(loadImage('assets/shark-running.png'), fb('run'));
    SPRITES.duck = await safe(loadImage('assets/shark-ducking.png'), fb('duck'));
    SPRITES.climb= await safe(loadImage('assets/shark-climb.png'), fb('climb'));
  }

  // ===== Input =====
  const keys = { left:false, right:false, upIntent:false, downIntent:false, jump:false, restart:false };
  const keydown = (e)=>{
    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','KeyA','KeyD','KeyW','KeyS','KeyR'].includes(e.code)) e.preventDefault();
    if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = true;
    if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right = true;
    if (e.code==='ArrowUp'   || e.code==='KeyW') keys.upIntent = true;
    if (e.code==='ArrowDown' || e.code==='KeyS') keys.downIntent = true;
    if (e.code==='Space') keys.jump = true;
    if (e.code==='KeyR') keys.restart = true;
  };
  const keyup = (e)=>{
    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','KeyA','KeyD','KeyW','KeyS','KeyR'].includes(e.code)) e.preventDefault();
    if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = false;
    if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right = false;
    if (e.code==='ArrowUp'   || e.code==='KeyW') keys.upIntent = false;
    if (e.code==='ArrowDown' || e.code==='KeyS') keys.downIntent = false;
    if (e.code==='Space') keys.jump = false;
    if (e.code==='KeyR') keys.restart = false;
  };
  window.addEventListener('keydown', keydown, { passive:false });
  window.addEventListener('keyup',   keyup,   { passive:false });

  // Touch joystick (2D for duck & climb) + jump
  const joy = document.getElementById('joystick');
  const stick = document.getElementById('stick');
  let joyActive=false, joyStartX=0, joyStartY=0;
  const JOY_MAX = 44, DEAD = 10;

  const setJoyFrom = (dx, dy)=>{
    dx = Math.max(-JOY_MAX, Math.min(JOY_MAX, dx));
    dy = Math.max(-JOY_MAX, Math.min(JOY_MAX, dy));
    stick.style.transform = `translate(${dx}px, ${dy}px)`;
    keys.left  = dx < -DEAD;
    keys.right = dx >  DEAD;
    keys.upIntent   = dy < -DEAD;
    keys.downIntent = dy >  DEAD;
  };

  joy.addEventListener('pointerdown', e=>{
    joyActive=true; joy.setPointerCapture(e.pointerId);
    joyStartX = e.clientX; joyStartY = e.clientY;
    setJoyFrom(0,0);
  });
  joy.addEventListener('pointermove', e=>{
    if(!joyActive) return;
    setJoyFrom(e.clientX - joyStartX, e.clientY - joyStartY);
  });
  const joyUp = ()=>{ joyActive=false; setJoyFrom(0,0); };
  joy.addEventListener('pointerup', joyUp);
  joy.addEventListener('pointercancel', joyUp);
  joy.addEventListener('pointerleave', joyUp);

  const btnJump = document.getElementById('btnJump');
  btnJump.addEventListener('pointerdown', e=>{ e.preventDefault(); keys.jump=true; });
  btnJump.addEventListener('pointerup',   e=>{ e.preventDefault(); keys.jump=false; });

  // ===== Game physics =====
  const G=2000, MAX_DX=360, JUMP_VY=700, accel=1800, CLIMB_SPEED=220;
  const player = { x:80, y:0, w:48, h:72, dx:0, dy:0, onGround:false, facing:1, animTime:0, state:'idle', onLadder:false };
  const SPRITE_H = 96; // target on-screen sprite height (keeps sizes consistent)

  // ===== Levels (10, last shows credits) =====
  const levels = [
    { platforms:[ {x:-200,y:420,w:700,h:40}, {x:650,y:360,w:170,h:22}, {x:880,y:420,w:500,h:40} ],
      ladders:[ {x:820,y:240,w:40,h:180} ],
      goal:{x:1320,y:318,w:30,h:142}, hazards:[] },

    { platforms:[ {x:-200,y:420,w:480,h:40}, {x:420,y:360,w:160,h:20}, {x:700,y:330,w:150,h:20}, {x:980,y:360,w:160,h:20}, {x:1260,y:420,w:520,h:40} ],
      ladders:[ {x:660,y:230,w:38,h:190} ],
      goal:{x:1680,y:318,w:30,h:142}, hazards:[ {x:870,y:402,w:70,h:18} ] },

    { platforms:[ {x:-220,y:420,w:560,h:40}, {x:520,y:340,w:180,h:20}, {x:860,y:300,w:180,h:20}, {x:1220,y:340,w:180,h:20}, {x:1560,y:420,w:520,h:40} ],
      ladders:[ {x:1180,y:220,w:38,h:200} ],
      goal:{x:1960,y:318,w:30,h:142}, hazards:[] },

    { platforms:[ {x:-200,y:420,w:2200,h:40} ],
      ladders:[ {x:620,y:240,w:40,h:180}, {x:1320,y:240,w:40,h:180} ],
      goal:{x:1880,y:318,w:30,h:142},
      hazards:[ {x:300,y:402,w:80,h:18},{x:540,y:402,w:80,h:18},{x:780,y:402,w:80,h:18},{x:1020,y:402,w:80,h:18},{x:1260,y:402,w:80,h:18},{x:1500,y:402,w:80,h:18} ] },

    { platforms:[ {x:-240,y:420,w:520,h:40}, {x:440,y:360,w:160,h:20}, {x:720,y:300,w:160,h:20}, {x:1000,y:260,w:160,h:20}, {x:1280,y:300,w:160,h:20}, {x:1560,y:360,w:160,h:20}, {x:1820,y:420,w:540,h:40} ],
      ladders:[ {x:980,y:200,w:38,h:180} ],
      goal:{x:2100,y:318,w:30,h:142},
      hazards:[ {x:840,y:402,w:80,h:18}, {x:1400,y:402,w:80,h:18} ] },

    { platforms:[ {x:-200,y:420,w:600,h:40}, {x:520,y:320,w:260,h:22}, {x:860,y:280,w:260,h:22}, {x:1200,y:320,w:260,h:22}, {x:1540,y:420,w:680,h:40} ],
      ladders:[ {x:1140,y:220,w:38,h:200} ],
      goal:{x:2000,y:318,w:30,h:142},
      hazards:[ {x:780,y:402,w:60,h:18}, {x:1120,y:402,w:60,h:18} ] },

    { platforms:[ {x:-220,y:420,w:520,h:40}, {x:460,y:420,w:240,h:40}, {x:820,y:420,w:240,h:40}, {x:1180,y:420,w:240,h:40}, {x:1540,y:420,w:540,h:40} ],
      ladders:[ {x:740,y:240,w:38,h:180}, {x:1100,y:240,w:38,h:180} ],
      goal:{x:1900,y:318,w:30,h:142},
      hazards:[ {x:700,y:402,w:60,h:18}, {x:1060,y:402,w:60,h:18} ] },

    { platforms:[ {x:-220,y:420,w:520,h:40}, {x:440,y:360,w:120,h:18}, {x:640,y:310,w:120,h:18}, {x:840,y:360,w:120,h:18}, {x:1040,y:310,w:120,h:18}, {x:1240,y:360,w:120,h:18}, {x:1440,y:420,w:640,h:40} ],
      ladders:[ {x:1000,y:210,w:34,h:200} ],
      goal:{x:1920,y:318,w:30,h:142},
      hazards:[ {x:760,y:402,w:80,h:18} ] },

    { platforms:[ {x:-240,y:420,w:560,h:40}, {x:520,y:340,w:160,h:20}, {x:760,y:260,w:160,h:20}, {x:1000,y:180,w:160,h:20}, {x:1240,y:260,w:160,h:20}, {x:1480,y:340,w:160,h:20}, {x:1720,y:420,w:560,h:40} ],
      ladders:[ {x:960,y:120,w:40,h:300} ],
      goal:{x:2040,y:318,w:30,h:142},
      hazards:[] },

    // 10: Finale -> Credits
    { platforms:[ {x:-200,y:420,w:2400,h:40} ],
      ladders:[ {x:600,y:240,w:40,h:180}, {x:1200,y:240,w:40,h:180}, {x:1800,y:240,w:40,h:180} ],
      goal:{x:2080,y:318,w:30,h:142},
      hazards:[ {x:300,y:402,w:80,h:18},{x:500,y:402,w:80,h:18},{x:700,y:402,w:80,h:18},{x:900,y:402,w:80,h:18},{x:1100,y:402,w:80,h:18},{x:1300,y:402,w:80,h:18},{x:1500,y:402,w:80,h:18},{x:1700,y:402,w:80,h:18} ],
      credits:true },
  ];
  let levelIndex=0; const cam={x:0,y:0}; let showCredits=false;
  const hudEl = document.getElementById('hud');

  function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  function loadLevel(i){
    showCredits = false;
    levelIndex = (i+levels.length)%levels.length;
    const L = levels[levelIndex];
    player.x = L.platforms[0].x + 80; player.y = L.platforms[0].y - 5;
    player.dx=0; player.dy=0; player.onGround=false; player.onLadder=false; player.state='idle';
    cam.x=0; cam.y=0;
    keys.left=keys.right=keys.upIntent=keys.downIntent=keys.jump=false;
    hudEl.textContent = `Level ${levelIndex+1} / ${levels.length}`;
    focusCanvas();
  }

  function moveAndCollide(dt, solids){
  // 1) Horizontal first
  player.x += player.dx * dt;
  collideAxis('x', solids);

  // 2) Vertical second (ladder overrides gravity motion)
  if (player.onLadder){
    let vy = 0;
    if (keys.upIntent) vy -= CLIMB_SPEED;
    if (keys.downIntent) vy += CLIMB_SPEED;
    player.y += vy * dt;
    player.dy = 0; // no gravity while climbing
  } else {
    player.y += player.dy * dt;
  }

  player.onGround = false;
  collideAxis('y', solids);
}

function collideAxis(axis, solids){
  // Tiny vertical inset during X checks to avoid floor grazing causing X snaps
  const inset = (axis === 'x') ? 1 : 0;
  const box = {
    x: player.x - player.w/2,
    y: player.y - player.h + inset,
    w: player.w,
    h: player.h - inset*2
  };

  for (const s of solids){
    // AABB test
    if (!(box.x < s.x + s.w && box.x + box.w > s.x &&
          box.y < s.y + s.h && box.y + box.h > s.y)) continue;

    if (axis === 'x'){
      if (player.dx > 0){ // moving right -> snap to left side of solid
        box.x = s.x - box.w; player.x = box.x + player.w/2; player.dx = 0;
      } else if (player.dx < 0){ // moving left -> snap to right side
        box.x = s.x + s.w; player.x = box.x + player.w/2; player.dx = 0;
      }
    } else { // axis === 'y'
      if (player.dy > 0){ // falling -> land on top
        box.y = s.y - box.h; player.y = box.y + player.h; player.dy = 0; player.onGround = true;
      } else if (player.dy < 0){ // moving up -> hit head
        box.y = s.y + s.h; player.y = box.y + player.h; player.dy = 0;
      }
    }
  }
}


  function update(dt){
    if (showCredits){
      if (keys.restart){ loadLevel(0); keys.restart=false; }
      return;
    }
    // horizontal input
    if (keys.left)  { player.dx = Math.max(player.dx - accel*dt, -MAX_DX); player.facing = -1; }
    if (keys.right) { player.dx = Math.min(player.dx + accel*dt,  MAX_DX); player.facing =  1; }
    if (!keys.left && !keys.right) player.dx *= Math.pow(0.0001, dt);

    // gravity + jump
    if (!player.onLadder) player.dy += G*dt;
    if (player.onGround && keys.jump){ player.dy = -JUMP_VY; player.onGround=false; }

    // Ladder detection
    const L = levels[levelIndex];
    const pbox = { x: player.x- player.w/2 + 6, y: player.y- player.h, w: player.w-12, h: player.h };
    const touchingLadder = L.ladders?.some(ld => aabb(pbox, ld));
    if (touchingLadder && (keys.upIntent || keys.downIntent)){
      player.onLadder = true;
      const ld = L.ladders.find(ld => aabb(pbox, ld));
      if (ld){ player.x = Math.max(ld.x + player.w/2, Math.min(ld.x + ld.w - player.w/2, player.x)); }
    } else if (!touchingLadder) {
      player.onLadder = false;
    }

    moveAndCollide(dt, L.platforms);

    // hazards / goal / fall reset
    if (L.hazards.some(h => aabb(pbox, h))) loadLevel(levelIndex);
    if (aabb(pbox, L.goal)){
      if (L.credits){ showCredits = true; }
      else { loadLevel(levelIndex+1); }
    }
    if (player.y > cvs.height + 600) loadLevel(levelIndex);

    // camera follow
    const targetX = player.x - cvs.width*0.35; cam.x += (targetX - cam.x) * Math.min(1, dt*5);

    // animation state
    if (player.onLadder) player.state = 'climb';
    else if (keys.downIntent && player.onGround) player.state = 'duck';
    else if (!player.onGround) player.state = 'air';
    else if (Math.abs(player.dx)>40) player.state = 'run';
    else player.state = 'idle';
    player.animTime += dt;
  }

  // --- Rounded rect helper ---
  function rr(g, x, y, w, h, r){ g.beginPath(); g.moveTo(x+r,y); g.lineTo(x+w-r,y); g.quadraticCurveTo(x+w,y,x+w,y+r);
    g.lineTo(x+w,y+h-r); g.quadraticCurveTo(x+w,y+h,x+w-r,y+h); g.lineTo(x+r,y+h); g.quadraticCurveTo(x,y+h,x,y+h-r); g.lineTo(x,y+r); g.quadraticCurveTo(x,y,x+r,y); g.closePath(); }

  function drawPlatform(p){
    ctx.fillStyle = 'rgba(0,0,0,.12)'; rr(ctx, p.x+3, p.y+6, p.w, p.h, 10); ctx.fill();
    ctx.fillStyle = '#67b95b'; rr(ctx, p.x, p.y, p.w, p.h, 10); ctx.fill();
    ctx.fillStyle = '#4a8f42'; rr(ctx, p.x, p.y, p.w, Math.min(6,p.h), 10); ctx.fill();
  }

  function drawLadder(ld){
    ctx.fillStyle='#caa96a'; ctx.fillRect(ld.x+6, ld.y, 8, ld.h);
    ctx.fillRect(ld.x+ld.w-14, ld.y, 8, ld.h);
    for(let r=0;r<Math.floor(ld.h/20);r++){ const ry = ld.y + r*20 + 8; ctx.fillRect(ld.x+12, ry, ld.w-24, 4); }
  }

  function drawCloud(x,y,s){
    ctx.fillStyle = 'rgba(255,255,255,.85)';
    ctx.beginPath();
    ctx.arc(x, y, 16*s, 0, Math.PI*2);
    ctx.arc(x+20*s, y-6*s, 14*s, 0, Math.PI*2);
    ctx.arc(x+40*s, y, 18*s, 0, Math.PI*2);
    ctx.fill();
  }

  function drawSpikeStrip(x,y,w,h){
    const n = Math.max(1, Math.floor(w/12));
    for(let i=0;i<n;i++){
      const sx = x + i*(w/n); ctx.fillStyle = '#e04a4a'; ctx.beginPath();
      ctx.moveTo(sx, y+h); ctx.lineTo(sx + (w/n)/2, y); ctx.lineTo(sx + (w/n), y+h); ctx.closePath(); ctx.fill();
    }
  }

  function drawCredits(){
    ctx.fillStyle = 'rgba(0,0,0,.35)'; ctx.fillRect(0,0,cvs.width,cvs.height);
    const cardW = Math.min(520, cvs.width - 60), cardH = 220;
    const x = (cvs.width - cardW)/2, y = (cvs.height - cardH)/2;
    ctx.fillStyle = '#ffffffee'; rr(ctx, x, y, cardW, cardH, 16); ctx.fill();
    ctx.fillStyle = '#111'; ctx.textAlign = 'center';
    ctx.font = 'bold 36px system-ui, sans-serif'; ctx.fillText('Credits', cvs.width/2, y + 64);
    ctx.font = '20px system-ui, sans-serif'; ctx.fillText('a special thanks to Nate and Matt', cvs.width/2, y + 108);
    ctx.font = '16px system-ui, sans-serif'; ctx.fillText('Press R or Tap to Restart', cvs.width/2, y + 160);
  }

  function draw(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    // Sky gradient
    const grd = ctx.createLinearGradient(0,0,0,cvs.height); grd.addColorStop(0,'#aee2ff'); grd.addColorStop(1,'#d9f4ff'); ctx.fillStyle=grd; ctx.fillRect(0,0,cvs.width,cvs.height);
    // Clouds
    for(let i=0;i<6;i++){ drawCloud((i*260 - (cam.x*0.2)%1560), 80 + (i%2)*24, 1+(i%3)*0.2); }

    ctx.save(); ctx.translate(-cam.x,0);
    const L = levels[levelIndex];

    // platforms / ladders / hazards / goal
    for (const p of L.platforms) drawPlatform(p);
    if (L.ladders) for (const ld of L.ladders) drawLadder(ld);
    for (const s of L.hazards) drawSpikeStrip(s.x, s.y, s.w, s.h);
    const g=L.goal; ctx.fillStyle='#ffcc00'; ctx.fillRect(g.x,g.y,6,g.h); ctx.fillStyle='#ff5d5d'; ctx.beginPath(); ctx.moveTo(g.x+6,g.y+8); ctx.lineTo(g.x+6+36,g.y+18); ctx.lineTo(g.x+6,g.y+28); ctx.closePath(); ctx.fill();

    // sprite (scaled to consistent height)
    let img=SPRITES.idle;
    if (player.state==='run' || player.state==='air') img=SPRITES.run;
    else if (player.state==='duck') img=SPRITES.duck;
    else if (player.state==='climb') img=SPRITES.climb;
    const fw=img.naturalWidth||img.width, fh=img.naturalHeight||img.height;
    const s = SPRITE_H / fh;
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.scale(player.facing * s, s);
    ctx.translate(-fw/2, -fh);
    ctx.imageSmoothingEnabled=false;
    ctx.drawImage(img,0,0);
    ctx.restore();

    ctx.restore();

    if (showCredits) drawCredits();
  }

  // ===== Loop =====
  let lastTs;
  function loop(ts){ const dt = Math.min(1/30, (ts-(lastTs||ts))/1000); lastTs=ts; update(dt); draw(); requestAnimationFrame(loop); }

  // Start game on image tap
  document.getElementById('startImage').addEventListener('click', async ()=>{
    document.getElementById('startScreen').classList.add('hidden');
    await ensureSprites();
    loadLevel(0);
    requestAnimationFrame(loop);
    focusCanvas();
  }, { passive:true });

  // Tap anywhere to restart while on credits
  document.addEventListener('pointerdown', ()=>{
    if (showCredits) loadLevel(0);
  }, { passive:true });

  // Prevent pull-to-refresh / bounce on mobile
  ['touchmove','gesturestart'].forEach(t=>addEventListener(t, e=>{ e.preventDefault(); }, { passive:false }));
  </script>
</body>
</html>
